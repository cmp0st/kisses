package server

import (
	"context"
	"errors"
	"log/slog"
	"net/http"
	"os"

	"cloud.google.com/go/firestore"
	"connectrpc.com/connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"google.golang.org/api/iterator"
	"google.golang.org/protobuf/proto"

	kissesv1 "github.com/cmp0st/kisses/server/gen/kisses/v1"        // generated by protoc-gen-go
	"github.com/cmp0st/kisses/server/gen/kisses/v1/kissesv1connect" // generated by protoc-gen-connect-go
)

type Server struct {
	db *firestore.Client
}

func (s *Server) GetKisses(
	ctx context.Context,
	req *connect.Request[kissesv1.GetKissesRequest],
) (*connect.Response[kissesv1.GetKissesResponse], error) {
	var kisses []*kissesv1.Kiss
	var from []string

	iter := s.db.Collection("kisses").Where("to", "==", req.Msg.To).Documents(ctx)
	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			slog.ErrorContext(ctx, "failed to read", slog.Any("err", err))
			return nil, errors.New("failed to read")
		}

		{
			f, err := doc.DataAt("from")
			if err != nil {
				slog.ErrorContext(ctx, "data corruption", slog.Any("err", err))
				return nil, err
			}
			from = append(from, f.(string))
		}
		{
			k, err := doc.DataAt("kiss")
			if err != nil {
				slog.ErrorContext(ctx, "data corruption", slog.Any("err", err))
				return nil, err
			}

			var kiss kissesv1.Kiss
			if err = proto.Unmarshal(k.([]byte), &kiss); err != nil {
				slog.ErrorContext(ctx, "data corruption", slog.Any("err", err))
				return nil, err
			}

			kisses = append(kisses, &kiss)
		}

		// Delete kisses that have been received
		_, err = doc.Ref.Delete(ctx)
		if err != nil {
			slog.WarnContext(ctx, "failed to delete", slog.Any("err", err))
		}
	}

	return connect.NewResponse(&kissesv1.GetKissesResponse{
		From:   from,
		Kisses: kisses,
	}), nil
}

func (s *Server) PostKiss(
	ctx context.Context,
	req *connect.Request[kissesv1.PostKissRequest],
) (*connect.Response[kissesv1.PostKissResponse], error) {
	buf, err := proto.Marshal(req.Msg.Kiss)
	if err != nil {
		slog.ErrorContext(ctx, "failed to proto.Marshal kiss", slog.Any("err", err))
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	_, _, err = s.db.Collection("kisses").Add(ctx, map[string]interface{}{
		"from": req.Msg.From,
		"to":   req.Msg.To,
		"kiss": buf,
	})
	if err != nil {
		slog.ErrorContext(ctx, "failed to write kiss", slog.Any("err", err))
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	return connect.NewResponse(&kissesv1.PostKissResponse{}), nil
}

func Run(ctx context.Context) error {
	project, ok := os.LookupEnv("GCP_PROJECT")
	if !ok {
		slog.ErrorContext(ctx, "misconfiguration: GCP_PROJECT not set")
		return errors.New("server misconfigured")
	}
	database, ok := os.LookupEnv("FIRESTORE_DATABASE")
	if !ok {
		slog.ErrorContext(ctx, "misconfiguration: FIRESTORE_DATABASE not set")
		return errors.New("server misconfigured")
	}

	client, err := firestore.NewClientWithDatabase(ctx, project, database)
	if err != nil {
		slog.ErrorContext(ctx, "failed to get client", slog.Any("err", err))
		return errors.New("failed to establish client")
	}

	greeter := &Server{
		db: client,
	}
	mux := http.NewServeMux()
	path, handler := kissesv1connect.NewKissesServiceHandler(greeter)
	mux.Handle(path, handler)
	return http.ListenAndServe(
		"0.0.0.0:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(mux, &http2.Server{}),
	)
}
